Greek text readable with "cat". Not with "pico".

sdi1900047

Το πρώτο ζητούμενο της εργασίας έχει υλοποιηθεί σε c++.

Είναι χωρισμένο σε 5 αρχεία κώδικα (manager.cpp, manager_funcs.cpp, worker.cpp, worker_funcs.cpp, close_report.cpp) και 3 κεφαλίδες
(manager_funcs.h, worker_funcs.h, close_report.h). Στο manager.cpp βρίσκεται ο κώδικας του manager και του listener, στο manager_funcs.cpp βοηθητικές
συναρτήσεις του manager, στο worker.cpp ο κώδικας του worker, στο worker_funcs.cpp βοηθητικές συναρτήσεις του worker, και στο close_report.cpp μια
βοηθητική συνάρτηση close_report που χρησιμοποιείται σε όλα τα άλλα αρχεία.

Τα αρχεία .cpp είναι στον κατάλογο src, τα .h στον include, τα .o μπαίνουν στον build, τα εκτελέσιμα στον bin (με την εξαίρεση του sniffer που
βρίσκεται στον αρχικό κατάλογο για να μπορεί να τρέχει όπως εξηγεί η εκφώνηση), τα fifos κατά την εκτέλεση στον pipes και τα αρχεία output στον
output.

Με την εντολή make all φτιάχνονται όλα τα εκτελέσιμα (sniffer και worker), με την make run φτιάχνονται όλα και τρέχει ο sniffer χωρίς ορίσματα,
με την make clean καθαρίζουν τα αντικειμενικά και τα εκτελέσιμα, και με την make cleanup καθαρίζεται το output.

Ο κώδικας έχει γραφτεί έτσι ώστε να διαχειρίζεται όλες τις περιπτώσεις λανθασμένου τερματισμού διαφόρων διεργασιών λόγω αποτυχημένων syscalls
καθώς και όλες τις πιθανές διακοπές syscalls από σήματα.

Έχει γίνει η σχεδιαστική επιλογή πως στην περίπτωση λάθους syscall ο worker τερματίζει άμεσα, κλείνωντας πρώτα τα ανοιχτά αρχεία και pipes, ενώ ο
manager κάνει την διαδικαστία τέλους σαν να είχε λάβει SIGINT. Εξαίρεση σε αυτόν τον κανόνα είναι το close(), που στην περίπτωση αποτυχίας εμφανίζει
τον λόγο λάθους στο stderr αλλά το πρόγραμμα συνεχίζει κανονικά. Αν τερματίσει με λάθος κάποιος worker για οποιονδήποτε λόγο το υπόλοιπο πρόγραμμα
λειτουργεί κανονικά, με το αρχείο το οποίο είχε ανατεθεί στον worker να είναι το μόνο που θα υποστεί πιθανώς πρόβλημα. Αν τερματίσει ο listener, ο
manager εκτελεί την διαδικασία τερματισμού.

Όταν αιτηθεί τερματισμός από τον χρήστη, το πρόγραμμα σταματάει να δουλεύει πάνω σε νέα αρχεία, τελειώνει αυτά που έχει αναλάβει ήδη, και μετά
τερματίζει.

Έχει γίνει επίσης η παραδοχή πως ο χρήστης δεν θα δώσει για παρακολούθηση τον κατάλογο του output ούτε αυτόν των pipes, και πως στον κατάλογο που
θα γίνεται η παρακολούθηση θα μπαίνουν μόνο αρχεία, τα οποία δεν θα αλλάζουν μετά.

Έχουν χρησιμοποιηθεί οι containers της stl της c++ για τις διάφορες δομές. Λόγω αυτών το valgrind  βγάζει κάποια still reachable memory leaks,
που όμως εξαφανίζονται αν μπεί όλος ο κώδικας της main πριν το exit σε αγκύλες, και έτσι λογικά απλά είναι λάθος και δεν υπάρχει κάποιο πραγματικό
leak.

Το πρόγραμμα λειτουργεί ως εξής:

Ο manager δημιουργεί τον listener (ο οποίος εκτελεί την inotifywait ώστε αυτή να ειδοποιεί μόνο για νέα αρχεία στον κατάλογο) και συνδέεται με αυτόν
με pipe. Θυμάται το pid του ώστε αν αυτός στείλει SIGCHLD o manager ξεκινάει την διαδικασία τερματισμού. Ο manager έπειτα μπαίνει στην κύρια επανάληψη
όπου πρώτα διαβάζει έναν αριθμό χαρακτήρων από τον listener, μπλοκάροντας αν δεν υπάρχει τίποτα, και μετά προσπελαύνει, έναν έναν τους χαρακτήρες στην
μνήμη. Αν βρεί αλλαγή γραμμής, που σημαίνει πως τελείωσε μια ειδοποίηση, μπλοκάρει τα σήματα και βάζει έναν worker να δουλέψει πάνω σε αυτό το αρχείο.
Αν δεν υπάρχει κάποιος διαθέσιμος, δημιουργεί έναν. Δημιουργεί πρώτα ένα named pipe, με όνομα αύξοντα αριθμό ("0", "1", κτλ.), και περνάει αυτό το όνομα
σαν όρισμα στον νέο worker που θα φτιάξει μέσω fork()->execl(). Ο worker κάνει το execl και ανοίγει το named pipe (χωρίς blocking ώστε να μην περιμένει
για τον manager), και μετά στέλτνει SIGSTOP στον εαυτό του. O manager κάνει waitpid και αν δεί πως το συγκεκριμένο παιδί σταμάτησε, τότε σημαίνει πως
όλα πήγαν καλά, του γράφει στο named pipe το όνομα του αρχίου πάνω στο οποίο πρέπει να δουλέψει και του στέλνει SIGCONT, βάζει σε ένα map το file
descriptor του named pipe ως προς το pid του αντίστοιχου worker, και αυξάνει το πλήθος ζωντανών workers κατά 1. Αν δεί πως το παιδί τερμάτισε, σημαίνει
πως κάτι πήγε λάθος με την execl ή την open, οπότε παρατάει τον συγκεκριμένο worker και συνεχίζει. Έτσι επιτυγχάνουμε να μην μπλοκάρει όλο το πρόγραμμα
λόγω λάθους σε έναν worker. Αν υπάρχει διαθέσιμος worker στην ουρά, ο manager τον βγάζει, του δίνει στο named pipe και του στέλνει SIGCONT. Αφού
τελειώσει την ανάθεση αρχείου ξεμπλοκάρει τα σήματα. Μετά από από κάθε read, αν έχει έρθει σήμα SIGCHLD, ο manager ενημερώνει την ουρά των διαθέσιμων
workers, καθώς και το πλήθως των ζωντανών workers, ανάλογα με το αν ο κάθε worker σταμάτησε ή τερμάτισε. Αν έχει έρθει SIGCHLD ή SIGINT ενώ ο manager
είναι μπλοκαρισμένος στην read, ξεμπλοκάρει και "μαζεύει"/τερματίζει αντίστοιχα. Αν έχει έρθει από πριν, δεν εκτελεί καν την read και απλά συνεχίζει,
κάνοντας την αντίστοιχη δουλειά. Ειδικά για το SIGINT, αν έρθει σήμα ανάμεσα στον έλεγχο του flag και το read, ο handler έχει φροντίσει να κάνει το read
non-blocking ώστε να μην χαθεί το σήμα και η διεργασία να σταματήσει, ακόμα κι αν δεν γράψει κάτι άλλο ο listener.

Ο worker αφού λάβει SIGCONT την πρώτη φορά από τον manager, μπαίνει σε μία επανάληψη που θα εκτελεί μέχρι να τερματίσει. Αρχικά μπλοκάρει σε ένα read
μέχρι ο manager να γράψει στο named pipe το όνομα του αρχείου στο οποίο πρέπει να δουλέψει. Όταν το διαβάσει, μπλοκάρει τα σήματα, εξάγει τα URLs
(διαβάζοντας ανά κομμάτια το αρχεία, και προσπελαύνοντας έναν έναν τους χαρακτήρες στην μνήμη, κρατώντας καταστάσεις με λογική FSM, και χρησιμοποιώντας
map/hash table της stl για τα URLs και τις εμφανίσεις τους ώστε να μείνει η πολυπλοκότητα βέλτιστη), τα γράφει σε ένα αρχείο .out που το βάζει στον
κατάλογο output/, και στέλνει SIGSTOP στον εαυτό του. Αγνοεί τα SIGINT, και αν λάβει SIGTERM πριν ή καθώς περιμένει στο read, τερματίζει.

Ο manager αφού βγεί από την κύρια επανάληψη λόγω SIGINT ξεκινάει την διαδικασία τερματισμού. Αρχικά μπλοκάρει τα σήματα, εφόσον δεν τα χρειάζεται πια
και δεν θέλουμε να διακόψουν syscall. Έπειτα στέλνει SIGINT στον listener, και κάνει waitpid για αυτόν. Μετά περιμένει για όλους τους workers που έχουν
μείνει ζωντανοί να σταματήσουν ή να τερματίσουν, αφήνοντάς τους πρώτα να τελειώσουν την δουλειά που τους έχει ανατεθεί. Μετά στέλνει σε όλους SIGCONT
και μετά SIGINT, ώστε να τερματίσουν. Έπειτα κάνει waitpid για όλα τα παιδιά, ώστε να μην μείνουν zombie. Μετά κλείνει και διαγράφει όλα τα named pipes,
και τερματίζει ο ίδιος.

Υπάρχει ο "κίνδυνος" να μπεί το manager στο σημείο του κώδικα όπου "μαζεύει" τους workers χωρίς να έχει έρθει SIGCHLD (αν π.χ. έρθει σήμα ενώ κάνει
την δουλειά, το οποίο ανεβάζει το flag ενώ ο αντίστοιχος worker μαζεύεται ήδη στον τρέχοντα βρόχο). Δεν υπάρχει πρόβλημα γιατί σε αυτήν την περίπτωση
απλά η waitpid θα επιστρέψει χωρίς να γίνει τίποτα. Δεν υπάρχει κίνδυνος να έχει τελειώσει worker και να έχει παραδοθεί SIGCHLD αλλά ο manager να μην τον
"μαζέψει" (εκτός αν είμαστε στην διαδικασία τερματισμού οπότε δεν μας νοιάζει να το βάλουμε στην ουρά).

Το δεύτερο ερώτημα έχει υλοποιηθεί σε bash. Χρησιμοποιείται associative array για να κρατήσει την πολυπλοκότητα βέλτιστη.

